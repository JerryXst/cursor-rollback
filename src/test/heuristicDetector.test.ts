import * as assert from 'assert';
import { HeuristicDetector } from '../cursor-companion/services/heuristicDetector';
import { CodeChange } from '../cursor-companion/models/codeChange';

suite('HeuristicDetector Tests', () => {
  let detector: HeuristicDetector;

  setup(() => {
    detector = new HeuristicDetector();
  });

  test('Should detect AI-generated code with explicit markers', () => {
    const changes: CodeChange[] = [
      {
        filePath: 'test.js',
        changeType: 'create',
        afterContent: `
          // Generated by Cursor AI
          function calculateTotal(items) {
            return items.reduce((sum, item) => sum + item.price, 0);
          }
        `
      }
    ];

    const result = detector.analyzeCodeChanges(changes);
    assert.strictEqual(result.isAiGenerated, true);
    assert.ok(result.confidence > 0.7, 'Confidence should be high');
    assert.ok(result.analysis.features.containsAiMarkers);
  });

  test('Should detect AI-generated code with explanatory comments', () => {
    const changes: CodeChange[] = [
      {
        filePath: 'test.js',
        changeType: 'create',
        afterContent: `
          // This function handles the calculation of total price
          // It takes an array of items and returns the sum of their prices
          function calculateTotal(items) {
            return items.reduce((sum, item) => sum + item.price, 0);
          }
        `
      }
    ];

    const result = detector.analyzeCodeChanges(changes);
    assert.strictEqual(result.isAiGenerated, true);
    assert.ok(result.confidence > 0.5, 'Confidence should be moderate');
    assert.ok(result.analysis.features.containsExplanatoryComments);
  });

  test('Should detect conversation boundary after time gap', () => {
    // First set of changes
    const changes1: CodeChange[] = [
      {
        filePath: 'test.js',
        changeType: 'create',
        afterContent: 'function test() { return true; }'
      }
    ];

    // Analyze first changes
    detector.analyzeCodeChanges(changes1);

    // Simulate time passing
    const originalNow = Date.now;
    try {
      // Mock Date.now to return a time 2 minutes in the future
      Date.now = () => originalNow() + 120000; // 2 minutes later

      // Second set of changes
      const changes2: CodeChange[] = [
        {
          filePath: 'test2.js',
          changeType: 'create',
          afterContent: 'function test2() { return false; }'
        }
      ];

      // Analyze second changes
      const result = detector.analyzeCodeChanges(changes2);
      
      assert.ok(result.conversationBoundary?.isNewConversation, 'Should detect new conversation');
      assert.ok(result.conversationBoundary?.reason.includes('Time gap'), 'Reason should mention time gap');
    } finally {
      // Restore original Date.now
      Date.now = originalNow;
    }
  });

  test('Should detect conversation boundary with explicit markers', () => {
    const changes: CodeChange[] = [
      {
        filePath: 'test.js',
        changeType: 'create',
        afterContent: `
          // Begin new conversation: Feature implementation
          function calculateTotal(items) {
            return items.reduce((sum, item) => sum + item.price, 0);
          }
        `
      }
    ];

    const result = detector.analyzeCodeChanges(changes);
    assert.ok(result.conversationBoundary?.isNewConversation, 'Should detect new conversation');
    assert.ok(result.conversationBoundary?.reason.includes('boundary marker'), 'Reason should mention boundary marker');
  });

  test('Should extract message content from comments', () => {
    const changes: CodeChange[] = [
      {
        filePath: 'test.js',
        changeType: 'create',
        afterContent: `
          /*
           * I've implemented the calculation function as requested.
           * This function takes an array of items and calculates the total price.
           * It uses the reduce method to iterate through each item and accumulate the sum.
           * Let me know if you need any clarification or have questions about the implementation.
           */
          function calculateTotal(items) {
            return items.reduce((sum, item) => sum + item.price, 0);
          }
        `
      }
    ];

    const result = detector.analyzeCodeChanges(changes);
    assert.ok(result.extractedMessage, 'Should extract message content');
    assert.strictEqual(result.extractedMessage?.sender, 'ai');
    assert.ok(result.extractedMessage?.content.includes('implemented the calculation function'), 
      'Extracted content should contain the comment text');
  });

  test('Should detect multiple file changes as likely AI-generated', () => {
    const changes: CodeChange[] = [
      {
        filePath: 'model.ts',
        changeType: 'create',
        afterContent: 'export interface User { id: string; name: string; }'
      },
      {
        filePath: 'service.ts',
        changeType: 'create',
        afterContent: 'export class UserService { getUser(id: string) { return null; } }'
      },
      {
        filePath: 'controller.ts',
        changeType: 'create',
        afterContent: 'export class UserController { constructor(private userService: UserService) {} }'
      }
    ];

    const result = detector.analyzeCodeChanges(changes);
    assert.ok(result.confidence > 0.5, 'Confidence should be moderate');
    assert.strictEqual(result.analysis.features.multipleFileChanges, true);
    assert.strictEqual(result.analysis.features.totalChanges, 3);
  });

  test('Should handle empty changes array', () => {
    const result = detector.analyzeCodeChanges([]);
    assert.strictEqual(result.isAiGenerated, false);
    assert.strictEqual(result.confidence, 0);
    assert.strictEqual(result.analysis.detectedPatterns.length, 0);
  });

  test('Should reset detector state', () => {
    // First analyze some changes
    const changes: CodeChange[] = [
      {
        filePath: 'test.js',
        changeType: 'create',
        afterContent: '// Generated by Cursor AI\nfunction test() {}'
      }
    ];
    
    detector.analyzeCodeChanges(changes);
    
    // Reset the detector
    detector.reset();
    
    // After reset, should treat next changes as first changes
    const newChanges: CodeChange[] = [
      {
        filePath: 'test2.js',
        changeType: 'create',
        afterContent: 'function test2() {}'
      }
    ];
    
    const result = detector.analyzeCodeChanges(newChanges);
    assert.ok(result.conversationBoundary?.isNewConversation, 'Should treat as new conversation after reset');
    assert.strictEqual(result.conversationBoundary?.reason, 'First detected changes');
  });
});