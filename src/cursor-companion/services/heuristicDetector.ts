import * as vscode from 'vscode';
import { CodeChange } from '../models/codeChange';
import { detectLanguage, calculateChecksum } from '../utils/helpers';

/**
 * Interface for heuristic detection results
 */
export interface HeuristicDetectionResult {
  /** Whether the changes are likely AI-generated */
  isAiGenerated: boolean;
  
  /** Confidence score (0-1) */
  confidence: number;
  
  /** Detected conversation boundary */
  conversationBoundary?: {
    /** Whether this is likely a new conversation */
    isNewConversation: boolean;
    
    /** Reason for the boundary detection */
    reason: string;
  };
  
  /** Extracted message content (if available) */
  extractedMessage?: {
    /** Content of the message */
    content: string;
    
    /** Whether this is from user or AI */
    sender: 'user' | 'ai';
  };
  
  /** Analysis details */
  analysis: {
    /** Patterns detected in the changes */
    detectedPatterns: string[];
    
    /** Features used for detection */
    features: Record<string, number | boolean | string>;
  };
}

/**
 * Service for heuristic detection of AI-generated code and conversation boundaries
 */
export class HeuristicDetector {
  // Patterns that suggest AI-generated code
  private readonly AI_CODE_PATTERNS = [
    /\/\/ Generated by .*(AI|Cursor|GPT|Copilot)/i,
    /\/\* Generated by .*(AI|Cursor|GPT|Copilot).*\*\//i,
    /# Generated by .*(AI|Cursor|GPT|Copilot)/i,
    /<!-- Generated by .*(AI|Cursor|GPT|Copilot) -->/i,
    /\/\/ This (code|file|implementation) was (created|generated|written) by/i,
    /\/\* This (code|file|implementation) was (created|generated|written) by.*\*\//i,
    /# This (code|file|implementation) was (created|generated|written) by/i,
    /<!-- This (code|file|implementation) was (created|generated|written) by -->/i,
    /\/\/ AI (generated|assisted|created)/i,
    /\/\* AI (generated|assisted|created).*\*\//i,
    /# AI (generated|assisted|created)/i,
    /<!-- AI (generated|assisted|created) -->/i
  ];
  
  // Patterns that suggest code comments explaining functionality (common in AI-generated code)
  private readonly EXPLANATORY_COMMENT_PATTERNS = [
    /\/\/ This (function|class|method|component) (handles|manages|implements|provides)/i,
    /\/\* This (function|class|method|component) (handles|manages|implements|provides).*\*\//i,
    /# This (function|class|method|component) (handles|manages|implements|provides)/i,
    /\/\/ (Function|Class|Method|Component) to (handle|manage|implement|provide)/i,
    /\/\* (Function|Class|Method|Component) to (handle|manage|implement|provide).*\*\//i,
    /# (Function|Class|Method|Component) to (handle|manage|implement|provide)/i
  ];
  
  // Patterns that suggest conversation boundaries
  private readonly CONVERSATION_BOUNDARY_PATTERNS = [
    /\/\/ (Begin|Start) (new|of) (conversation|implementation|feature)/i,
    /\/\* (Begin|Start) (new|of) (conversation|implementation|feature).*\*\//i,
    /# (Begin|Start) (new|of) (conversation|implementation|feature)/i,
    /\/\/ (End|Finish) (of) (conversation|implementation|feature)/i,
    /\/\* (End|Finish) (of) (conversation|implementation|feature).*\*\//i,
    /# (End|Finish) (of) (conversation|implementation|feature)/i
  ];
  
  // File change history for pattern detection
  private fileChangeHistory: Map<string, {
    changes: Array<{
      timestamp: number;
      changeType: 'create' | 'modify' | 'delete';
      content?: string;
      checksum?: string;
    }>;
    lastAiConfidence: number;
  }> = new Map();
  
  // Recent code changes for conversation boundary detection
  private recentCodeChanges: Array<{
    timestamp: number;
    filePath: string;
    changeType: 'create' | 'modify' | 'delete';
    content?: string;
    aiConfidence: number;
  }> = [];
  
  // Time window for grouping changes (ms)
  private readonly CHANGE_GROUP_WINDOW = 5000; // 5 seconds
  
  // Time threshold for conversation boundary (ms)
  private readonly CONVERSATION_BOUNDARY_THRESHOLD = 60000; // 1 minute
  
  // Minimum confidence threshold for AI detection
  private readonly MIN_AI_CONFIDENCE = 0.6;
  
  /**
   * Analyze code changes to detect if they are AI-generated
   * @param codeChanges Array of code changes to analyze
   * @returns Detection result with confidence score and analysis
   */
  public analyzeCodeChanges(codeChanges: CodeChange[]): HeuristicDetectionResult {
    if (!codeChanges.length) {
      return this.createEmptyResult();
    }
    
    // Track features for detection
    const features: Record<string, number | boolean | string> = {
      totalChanges: codeChanges.length,
      hasCreateOperations: false,
      hasModifyOperations: false,
      hasDeleteOperations: false,
      multipleFileChanges: codeChanges.length > 1,
      multipleLanguages: false,
      containsAiMarkers: false,
      containsExplanatoryComments: false,
      averageChangeSize: 0,
      maxChangeSize: 0,
      totalChangeSize: 0,
      languages: new Set<string>(),
      patternMatchCount: 0,
      timeGrouped: false
    };
    
    // Detected patterns
    const detectedPatterns: string[] = [];
    
    // Track languages
    const languages = new Set<string>();
    
    // Analyze each change
    let totalContentSize = 0;
    let maxContentSize = 0;
    let patternMatchCount = 0;
    
    // Check time grouping
    const timestamps = codeChanges
      .filter(change => change.metadata?.timestamp)
      .map(change => change.metadata!.timestamp!);
    
    if (timestamps.length > 1) {
      const minTimestamp = Math.min(...timestamps);
      const maxTimestamp = Math.max(...timestamps);
      features.timeGrouped = (maxTimestamp - minTimestamp) < this.CHANGE_GROUP_WINDOW;
    }
    
    // Process each code change
    for (const change of codeChanges) {
      // Track change types
      switch (change.changeType) {
        case 'create':
          features.hasCreateOperations = true;
          break;
        case 'modify':
          features.hasModifyOperations = true;
          break;
        case 'delete':
          features.hasDeleteOperations = true;
          break;
      }
      
      // Get content to analyze
      const content = change.changeType === 'delete' 
        ? change.beforeContent || ''
        : change.afterContent || '';
      
      // Track content size
      const contentSize = content.length;
      totalContentSize += contentSize;
      maxContentSize = Math.max(maxContentSize, contentSize);
      
      // Detect language
      const language = detectLanguage(change.filePath);
      languages.add(language);
      
      // Check for AI markers
      for (const pattern of this.AI_CODE_PATTERNS) {
        if (pattern.test(content)) {
          features.containsAiMarkers = true;
          detectedPatterns.push(`AI marker: ${pattern.toString()}`);
          patternMatchCount++;
        }
      }
      
      // Check for explanatory comments
      for (const pattern of this.EXPLANATORY_COMMENT_PATTERNS) {
        if (pattern.test(content)) {
          features.containsExplanatoryComments = true;
          detectedPatterns.push(`Explanatory comment: ${pattern.toString()}`);
          patternMatchCount++;
        }
      }
      
      // Update file history
      this.updateFileHistory(change);
    }
    
    // Update feature calculations
    features.averageChangeSize = totalContentSize / codeChanges.length;
    features.maxChangeSize = maxContentSize;
    features.totalChangeSize = totalContentSize;
    features.multipleLanguages = languages.size > 1;
    features.languages = Array.from(languages);
    features.patternMatchCount = patternMatchCount;
    
    // Calculate confidence score
    const confidence = this.calculateAiConfidence(features);
    
    // Check for conversation boundary
    const conversationBoundary = this.detectConversationBoundary(codeChanges, confidence);
    
    // Extract message content if possible
    const extractedMessage = this.extractMessageContent(codeChanges);
    
    // Update recent code changes for future boundary detection
    this.updateRecentCodeChanges(codeChanges, confidence);
    
    return {
      isAiGenerated: confidence >= this.MIN_AI_CONFIDENCE,
      confidence,
      conversationBoundary,
      extractedMessage,
      analysis: {
        detectedPatterns,
        features
      }
    };
  }
  
  /**
   * Calculate confidence score that changes are AI-generated
   * @param features Extracted features from code changes
   * @returns Confidence score between 0 and 1
   */
  private calculateAiConfidence(features: Record<string, number | boolean | string>): number {
    let score = 0;
    let maxScore = 0;
    
    // Explicit AI markers are strong indicators
    if (features.containsAiMarkers) {
      score += 5;
    }
    maxScore += 5;
    
    // Explanatory comments are moderate indicators
    if (features.containsExplanatoryComments) {
      score += 3;
    }
    maxScore += 3;
    
    // Multiple files changed at once is a moderate indicator
    if (features.multipleFileChanges) {
      score += 2;
    }
    maxScore += 2;
    
    // Changes across multiple languages is a moderate indicator
    if (features.multipleLanguages) {
      score += 2;
    }
    maxScore += 2;
    
    // Time grouping is a moderate indicator
    if (features.timeGrouped) {
      score += 2;
    }
    maxScore += 2;
    
    // Pattern match count
    score += Math.min(features.patternMatchCount as number, 3);
    maxScore += 3;
    
    // Large changes are a weak indicator
    if ((features.averageChangeSize as number) > 500) {
      score += 1;
    }
    maxScore += 1;
    
    // Calculate final confidence
    return score / maxScore;
  }
  
  /**
   * Update file change history
   * @param change Code change to add to history
   */
  private updateFileHistory(change: CodeChange): void {
    const filePath = change.filePath;
    const timestamp = Date.now();
    const content = change.changeType === 'delete' 
      ? change.beforeContent || ''
      : change.afterContent || '';
    const checksum = calculateChecksum(content);
    
    // Get or create history entry
    const history = this.fileChangeHistory.get(filePath) || {
      changes: [],
      lastAiConfidence: 0
    };
    
    // Add change to history
    history.changes.push({
      timestamp,
      changeType: change.changeType,
      content,
      checksum
    });
    
    // Limit history size
    if (history.changes.length > 10) {
      history.changes = history.changes.slice(-10);
    }
    
    // Update history
    this.fileChangeHistory.set(filePath, history);
  }
  
  /**
   * Update recent code changes for conversation boundary detection
   * @param changes Code changes to add
   * @param aiConfidence Confidence score for AI generation
   */
  private updateRecentCodeChanges(changes: CodeChange[], aiConfidence: number): void {
    const timestamp = Date.now();
    
    // Add each change to recent changes
    for (const change of changes) {
      const content = change.changeType === 'delete' 
        ? change.beforeContent || ''
        : change.afterContent || '';
      
      this.recentCodeChanges.push({
        timestamp,
        filePath: change.filePath,
        changeType: change.changeType,
        content,
        aiConfidence
      });
    }
    
    // Limit recent changes size
    if (this.recentCodeChanges.length > 50) {
      this.recentCodeChanges = this.recentCodeChanges.slice(-50);
    }
  }
  
  /**
   * Detect if changes represent a conversation boundary
   * @param changes Code changes to analyze
   * @param aiConfidence Confidence score for AI generation
   * @returns Conversation boundary detection result
   */
  private detectConversationBoundary(changes: CodeChange[], aiConfidence: number): HeuristicDetectionResult['conversationBoundary'] {
    // If no recent changes, this is a new conversation
    if (this.recentCodeChanges.length === 0) {
      return {
        isNewConversation: true,
        reason: 'First detected changes'
      };
    }
    
    // Check for explicit boundary markers in code
    for (const change of changes) {
      const content = change.changeType === 'delete' 
        ? change.beforeContent || ''
        : change.afterContent || '';
      
      for (const pattern of this.CONVERSATION_BOUNDARY_PATTERNS) {
        if (pattern.test(content)) {
          return {
            isNewConversation: true,
            reason: `Detected boundary marker: ${pattern.toString()}`
          };
        }
      }
    }
    
    // Check time gap from last changes
    const currentTime = Date.now();
    const lastChangeTime = Math.max(...this.recentCodeChanges.map(c => c.timestamp));
    const timeSinceLastChange = currentTime - lastChangeTime;
    
    if (timeSinceLastChange > this.CONVERSATION_BOUNDARY_THRESHOLD) {
      return {
        isNewConversation: true,
        reason: `Time gap of ${Math.round(timeSinceLastChange / 1000)}s since last changes`
      };
    }
    
    // Check for significant change in AI confidence
    const recentAiConfidences = this.recentCodeChanges
      .slice(-5)
      .map(c => c.aiConfidence);
    
    if (recentAiConfidences.length > 0) {
      const avgRecentConfidence = recentAiConfidences.reduce((a, b) => a + b, 0) / recentAiConfidences.length;
      const confidenceDelta = Math.abs(aiConfidence - avgRecentConfidence);
      
      if (confidenceDelta > 0.3) {
        return {
          isNewConversation: true,
          reason: `Significant change in AI confidence (delta: ${confidenceDelta.toFixed(2)})`
        };
      }
    }
    
    // Check for changes in different file sets
    const recentFilePaths = new Set(this.recentCodeChanges.slice(-10).map(c => c.filePath));
    const currentFilePaths = new Set(changes.map(c => c.filePath));
    const commonFiles = [...currentFilePaths].filter(file => recentFilePaths.has(file));
    
    if (commonFiles.length === 0 && currentFilePaths.size > 0 && recentFilePaths.size > 0) {
      return {
        isNewConversation: true,
        reason: 'Complete change in affected files'
      };
    }
    
    // Not a conversation boundary
    return {
      isNewConversation: false,
      reason: 'Continuing existing conversation'
    };
  }
  
  /**
   * Extract potential message content from code changes
   * @param changes Code changes to analyze
   * @returns Extracted message if found
   */
  private extractMessageContent(changes: CodeChange[]): HeuristicDetectionResult['extractedMessage'] | undefined {
    // Look for comment blocks that might contain conversation content
    for (const change of changes) {
      const content = change.changeType === 'delete' 
        ? change.beforeContent || ''
        : change.afterContent || '';
      
      // Look for multi-line comments
      const multiLineComments = content.match(/\/\*[\s\S]*?\*\//g) || [];
      for (const comment of multiLineComments) {
        // Clean up comment markers and whitespace
        const cleaned = comment
          .replace(/\/\*|\*\//g, '')
          .trim();
        
        // If it's substantial, it might be a message
        if (cleaned.length > 50) {
          return {
            content: cleaned,
            sender: 'ai' // Assume AI for comments in code
          };
        }
      }
      
      // Look for consecutive single-line comments
      const lines = content.split('\n');
      let commentBlock = '';
      let inCommentBlock = false;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        if (trimmed.startsWith('//') || trimmed.startsWith('#')) {
          // Continue or start comment block
          inCommentBlock = true;
          commentBlock += trimmed.replace(/^\/\/|^#/, '').trim() + '\n';
        } else if (inCommentBlock) {
          // End of comment block
          break;
        }
      }
      
      // If we found a substantial comment block
      if (commentBlock.length > 50) {
        return {
          content: commentBlock.trim(),
          sender: 'ai' // Assume AI for comments in code
        };
      }
    }
    
    return undefined;
  }
  
  /**
   * Create an empty result for when no changes are provided
   */
  private createEmptyResult(): HeuristicDetectionResult {
    return {
      isAiGenerated: false,
      confidence: 0,
      analysis: {
        detectedPatterns: [],
        features: {
          totalChanges: 0
        }
      }
    };
  }
  
  /**
   * Reset the detector state
   */
  public reset(): void {
    this.fileChangeHistory.clear();
    this.recentCodeChanges = [];
  }
}